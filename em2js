#!/usr/bin/env node
// by Han Seoul-Oh <laughinghan@gmail.com> (http://github.com/laughinghan)

// Coding Style: as a personal experiment, this script shall be written in
// [npm's "funny" coding style](https://docs.npmjs.com/misc/coding-style)
// aka "semicolon-free"

var input = lex(parse(codegen(function output (o) { process.stdout.write(o) })))

var data = ''
process.stdin.setEncoding('utf8')
process.stdin.on('readable', function () { data += process.stdin.read() || '' })
process.stdin.on('end', function () { input(data) })

function lex (emit) {
  return function(source) {
    (source+'\n').match(/[+-]?([0-9]+|[0-9]*\.[0-9]+)(e[+-]?[0-9]+)?|"([^"\\]|\\"|\\\\)*"|[a-z][a-z0-9]*|\\?[ \t]*(#[^\n]*)?\n|\S/ig).map(emit)
    emit('<EOF>')
  }
}

function parse (emit) {
  var exprs = []
  return function _parse (token) {
    console.error('parsing:', token)

    if (token === '<EOF>' || token === ';' || token.slice(-1) === '\n') {
      if (token.charAt(0) === '\\') return // line continuation
      if (exprs.length === 0) return // empty line
      if (token === '<EOF>') {
        console.error('exprs:', require('util').inspect(exprs, { depth: null }))
        throw 'Unexpected end of input'
      }
      if (exprs.slice(-1)[0].type === 'OpenGroup') return
      if (exprs.length === 1) {
        emit(exprs.pop())
      } else if (exprs.length > 1) {
        var group = exprs.slice(-2)[0]
        if (group.type !== 'OpenGroup') throw 'Unexpected end of statement'
        group.stmts.push(exprs.pop())
      }
      return
    }
    var newExpr
    if (!isNaN(parseFloat(token))) {
      newExpr = { type: 'Num', value: parseFloat(token) }
    } else if (token.charAt(0) === '"') {
      newExpr = { type: 'Str', value: token.slice(1,-1).replace(/\\(["\\])/g, '$1') }
    } else if (token === '.') {
      exprs.push('.')
      return
    } else if (token === '^') {
      var peek = exprs.slice(-1)[0]
      if (!peek || peek.type !== 'Closure' || peek.body) {
        exprs.push({ type: 'Closure', args: [] })
      }
      return
    } else if (/[a-z][a-z0-9]*/.test(token)) {
      var peek = exprs.slice(-1)[0]
      if (peek && peek.type === 'Closure' && !peek.body) {
        peek.args.push(token)
        return
      } else if (peek === '.') {
        exprs.pop()
        newExpr = { type: 'Atom', value: token }
      } else {
        newExpr = { type: 'Ident', value: token }
      }
    } else if (token === '(') {
      exprs.push({ type: 'OpenGroup', stmts: [] })
      return
    } else if (token === ')') {
      newExpr = exprs.pop()
      if (!newExpr) throw 'Unmatched ")"'
      if (newExpr.type !== 'OpenGroup') {
        var group = exprs.pop()
        if (group.type !== 'OpenGroup') throw 'Unmatched ")"'
        group.stmts.push(newExpr)
        newExpr = group
      }
      newExpr.type = 'Group'

      var peek = exprs.slice(-1)[0]
      if (peek && peek.type === 'Closure' && !peek.body) {
        peek.body = newExpr
        newExpr = exprs.pop()
      }
    } else {
      throw 'Unexpected "'+token+'"'
    }
    var prevExpr = exprs.slice(-1)[0]
    if (!prevExpr || prevExpr.type === 'OpenGroup') exprs.push(newExpr)
    else {
      exprs.pop()
      exprs.push({ type: 'FnCall', fn: prevExpr, arg: newExpr })
    }
  }
}

function codegen (emit) {
  emit(require('fs').readFileSync('./runtime.js', { encoding: 'utf8' }) + '\n')
  return function _codegen (stmt) {
    console.error('codegen:', stmt)

    emit(';')
    outputExpr(stmt)
    emit('\n')
  }
  function outputExpr (expr) {
    emit('(')
    if (expr.type === 'Group') {
      if (expr.stmts.length === 0) emit('undefined')
      else {
        emit('(')
        expr.stmts.slice(0, -1).forEach(function (stmt) {
          outputExpr(stmt)
          emit(', ')
        })
        outputExpr(expr.stmts.slice(-1)[0])
        emit(')')
      }
    } else if (expr.type === 'FnCall') {
      outputExpr(expr.fn)
      outputExpr(expr.arg)
    } else if (expr.type === 'Closure') {
      emit('Closure(scope, "' + expr.args + '".split(","), ')
      emit('function (scope) { return ')
      outputExpr(expr.body)
      emit(' })')
    } else if (expr.type === 'Ident') {
      emit('scope.$' + expr.value)
    } else if (expr.type === 'Atom') {
      emit('"' + expr.value + '"')
    } else if (expr.type === 'Str') {
      emit('new String(' + JSON.stringify(expr.value) + ')')
    } else if (expr.type === 'Num') {
      emit('Num(' + expr.value + ')')
    } else {
      console.error('expr:', expr)
      throw 'Invalid parse node encountered'
    }
    emit(')')
  }
}
